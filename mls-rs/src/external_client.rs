// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// Copyright by contributors to this project.
// SPDX-License-Identifier: (Apache-2.0 OR MIT)

use crate::{
    cipher_suite::CipherSuite,
    client::MlsError,
    group::{framing::MlsMessage, ExportedTree},
    key_package::{validate_key_package_properties, KeyPackage},
    protocol_version::ProtocolVersion,
    time::MlsTime,
    tree_kem::leaf_node_validator::{LeafNodeValidator, ValidationContext},
    CryptoProvider,
};

pub mod builder;
mod config;
mod group;

pub(crate) use config::ExternalClientConfig;
use mls_rs_core::{crypto::SignatureSecretKey, identity::SigningIdentity};

use builder::{ExternalBaseConfig, ExternalClientBuilder};

pub use group::{ExternalGroup, ExternalReceivedMessage, ExternalSnapshot};

/// A client capable of observing a group's state without having
/// private keys required to read content.
///
/// This structure is useful when an application is sending
/// plaintext control messages in order to allow a central server
/// to facilitate communication between users.
///
/// # Warning
///
/// This structure will only be able to observe groups that were
/// created by clients that have the `encrypt_control_messages`
/// option returned by [`MlsRules::encryption_options`](`crate::MlsRules::encryption_options`)
/// set to `false`. Any control messages that are sent encrypted
/// over the wire will break the ability of this client to track
/// the resulting group state.
pub struct ExternalClient<C> {
    config: C,
    signing_data: Option<(SignatureSecretKey, SigningIdentity)>,
}

impl ExternalClient<()> {
    pub fn builder() -> ExternalClientBuilder<ExternalBaseConfig> {
        ExternalClientBuilder::new()
    }
}

impl<C> ExternalClient<C>
where
    C: ExternalClientConfig + Clone,
{
    pub(crate) fn new(
        config: C,
        signing_data: Option<(SignatureSecretKey, SigningIdentity)>,
    ) -> Self {
        Self {
            config,
            signing_data,
        }
    }

    /// Begin observing a group based on a GroupInfo message created by
    /// [Group::group_info_message](crate::group::Group::group_info_message)
    ///
    ///`tree_data` is required to be provided out of band if the client that
    /// created GroupInfo message did not did not use the `ratchet_tree_extension`
    /// according to [`MlsRules::commit_options`](crate::MlsRules::commit_options)
    /// at the time the welcome message
    /// was created. `tree_data` can be exported from a group using the
    /// [export tree function](crate::group::Group::export_tree).
    #[cfg_attr(not(mls_build_async), maybe_async::must_be_sync)]
    pub async fn observe_group(
        &self,
        group_info: MlsMessage,
        tree_data: Option<ExportedTree<'_>>,
    ) -> Result<ExternalGroup<C>, MlsError> {
        ExternalGroup::join(
            self.config.clone(),
            self.signing_data.clone(),
            group_info,
            tree_data,
        )
        .await
    }

    /// Load an existing observed group by loading a snapshot that was
    /// generated by
    /// [ExternalGroup::snapshot](self::ExternalGroup::snapshot).
    #[cfg_attr(not(mls_build_async), maybe_async::must_be_sync)]
    pub async fn load_group(
        &self,
        snapshot: ExternalSnapshot,
    ) -> Result<ExternalGroup<C>, MlsError> {
        ExternalGroup::from_snapshot(self.config.clone(), snapshot).await
    }

    /// Utility function to validate key packages
    #[cfg_attr(not(mls_build_async), maybe_async::must_be_sync)]
    pub async fn validate_key_package(
        &self,
        package: MlsMessage,
        protocol: ProtocolVersion,
        cipher_suite: CipherSuite,
    ) -> Result<KeyPackage, MlsError> {
        let key_package = package
            .into_key_package()
            .ok_or(MlsError::UnexpectedMessageType)?;

        let cs = self
            .config
            .crypto_provider()
            .cipher_suite_provider(cipher_suite)
            .ok_or_else(|| MlsError::UnsupportedCipherSuite(cipher_suite))?;

        let id_provider = self.config.identity_provider();

        let validator = LeafNodeValidator::new(&cs, &id_provider, None);
        let context = ValidationContext::Add(Some(MlsTime::now()));

        validator
            .check_if_valid(&key_package.leaf_node, context)
            .await?;

        validate_key_package_properties(&key_package, protocol, &cs).await?;

        Ok(key_package)
    }
}

#[cfg(test)]
pub(crate) mod tests_utils {
    pub use super::builder::test_utils::*;
}
